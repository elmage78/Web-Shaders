<!DOCTYPE html>
<html>
<head>
    <title>Shadering w/furry</title>
    <link rel="stylesheet" type="text/css" href="../Home.css">
    <link rel="stylesheet" type="text/css" href="Screensaver.css">
    <header>
        <h1 class="centered">Screensaver</h1>
        <p class="centered">A simple shader in a senoidal wave</p>
    </header>
</head>

<body>
    <main>
        <h2>UV setup</h2>
        <section>
            <p>First we will modify UV so it “moves” to the center starting at (-1,-1) and ending at (1,1) for that we take f(x,y) = (Coord.xy / (Resolution.xy * 2.0))- 1.0 that way let's take a coordinate (1980/2,1080/2) the middle and input it getting f(1980/2,1080/2)= (1980/2,1080/2)/(1980,1080)*2.0 we can simplify to (1980,1080)/(1980,1080)- 1.0 that way the output is the value (0.0,0.0)</p>
            <p>This part can be skipped but we will make the uv a square so the diagonal gives a module of 1 (the uv = square) to do that we multiply the UV.x x coordinate which is the bigger one by the relation between the Resolution.x/Resolution.y relation that way we get square</p>
            <img src="UVmapD.png" class="uvMAP">
        </section>
        <section>
            <h2>Math and reasoning</h2>
            <p>Ok so for this screen saver we are gonna make some balls that appear to stay floating around a fixed point well to do that we will Determine a circle's position as a vector that avanzes through time on a senoidal wave that way we get the function f(x,y) = cos(iTime)*x + sin(iTime) * y now we have their positions but to draw them we need a radius and to make it a bit more dynamic we will make it dependent on time r(x) = (0.1 + sin(iTime * 0.7) * 0.1 )* x; now to make them colourfull we will change the r,g,b with this function (trying different constants and changing them results on different color patterns)</p>
            <Math>
                rgb(r,g,b) = r* vec3(sin(iTime * 0.5) * 0.5 + 0.5+ g * sin(iTime * 0.6) * 0.5 + 0.5+ b * sin( * 0.4 + iTime * 0.7) * 0.5 + 0.5)
            </Math>
            <p>Now to have more than 1 ball we will have a variable i that loops these trough x amount of balls and augmenting 1 by each and to make the balls different in color and radius and etc we will put the variable i itself on the function such as</p>
            <Math>
                rgb(r,g,b) = vec3(sin(float(i) + iTime) + sin(float(i) + iTime)+ sin(float(i) + iTime));
                r(x) = (0.1 + sin(iTime * 0.7 + float(i) * 0.4) * 0.1 )* x;
                f(x,y) = vec2(cos(iTime * 0.5 + float(i) * 0.3) * 0.5*x + sin(iTime * 0.3  + float(i) * 0.7) * 0.5) * y;
            </Math>
            <p>That would be it… now translating it to glsl code it will give us this functions</p>
        </section>
        <section>
            <pre><code>
                void mainImage(out vec4 O, vec2 F) {
                    vec2 u = F / iResolution.xy * 2.0 - 1.0;
                    u.x *= iResolution.x / iResolution.y;
                    
                    O = vec4(0.0);
                    
                    for (int i = 0; i < 20; i++) {
                        vec2 pos = vec2(cos(iTime * 0.5 + float(i) * 0.3) * 0.5, sin(iTime * 0.3  + float(i) * 0.7) * 
                        0.5);

                        float radius = 0.1 + sin(iTime * 0.7 + float(i) * 0.4) * 0.1;
                        vec3 color = vec3(sin(float(i) * 0.2 + iTime * 0.5) * 0.5 + 0.5,
                                          sin(float(i) * 0.3 + iTime * 0.6) * 0.5 + 0.5,
                                          sin(float(i) * 0.4 + iTime * 0.7) * 0.5 + 0.5);
                        
                        float dist = length(u - pos);
                        O += vec4(color, 1.0) * smoothstep(radius, radius * 0.9, dist);
                    }
                }
            </code></pre>
            <h2>Now the actual computed shader</h2>
        </section>
        <canvas id="space" class="container2"></canvas>
        <script src="Shader.js"></script>
    </main>
</body>
</html>