<!DOCTYPE html>
<html>
<head>
    <title>Shadering w/furry</title>
    <link rel="stylesheet" type="text/css" href="Home.css">
    <script src="Home.js"></script>
    <header>
        <h1 class="centered">Bienvenidos a shaders</h1>
        <p class="centered">Una guía sin mucho detalle de shaders</p>
    </header>
</head>

<body>
    <nav class="menu">
        <div class="dropdown">
            <button onclick="Dropdown()" class="dropbtn">Fragment Shaders</button>
            <div id="myDropdown" class="dropdown-content">
              <a href="Shaders\Screensaver.html">Salvapantallas</a>
              <a href="Shaders/Sdf.html">Sdf introducción</a>
            </div>
          </div>
    </nav>
    <main>
        <section>
            <h2>Tipos de Shaders</h2>
            <p>There are many different types of shaders, including:</p>
            <ul>
                <li>Shaders de vértices: estos Shaders operan en cada vértice individual de un modelo 3D.</li>
                <li>Shaders de píxeles: estos Shaders operan en cada píxel individual de una imagen 2D o escena 3D.</li>
                <li>Shaders de geometría: estos Shaders operan en formas enteras o grupos de vértices.</li>
                <li>Shaders de computación: estos Shaders operan con grandes conjuntos de datos y se pueden usar para computación de propósito general en la GPU.</li>
            </ul>
        </section>
        <section>
            <h2>Ejemplo</h2>
            <p>Este sería un ejemplo de un shader</p>
            <pre><code>
                #version 330 core

                void main() {
                    gl_FragColor = vec4(1.0, 0.5, 0.31, 1.0);
                }
            </code></pre>
        </section>
        <section>
            <p>en este Shaders específico indicamos la versión y coloreamos la salida, por lo que básicamente se colorea con un color #ff7523</p>
        </section>
        <section>
            <h2>¿Qué es un shader?</h2>
            <p>
                Un Shader es un cálculo de ecuaciones matemáticas con diferentes variables en las que el resultado es un vector de 4 dígitos (x,y,z,w) donde los primeros números representan el color de un píxel <b>rgb</b> y la w representa el alfa del mismo píxel, estos valores se manejan en un valor hexadecimal para que el valor mínimo sea 00 y el máximo sea ff. Es posible que reconozcas bien este formato al ingresar #ffffff si aún no sabes que estos valores representan rgb de algo. Entonces, para un píxel semitransparente violeta (rojo + azul), obtendrías ff 00 ff 7E.
            </p>
            <h2>Los inicios</h2>
            <p>
                Ahora, para los sombreadores, generalmente obtienes una función con más de 4 variables y algunas constantes. Normalmente obtendrías la coordenada de un píxel. El problema es que diferentes pantallas con diferentes resoluciones obtienen diferentes coordenadas para el último píxel, digamos (720,720) o (1980,1080). ) ¿Entonces lo que hay que hacer? Por defecto hay un término que llamamos UV que está representado por la fórmula f(x,y) = fragCoord.xy / Resolución.xy que para cualquier punto de cualquier pantalla da un vector normalizado con máximo (1,1) y mínimo ( 0,0) si pasamos eso directamente a la salida del vector 4, obtendrás esta imagen (rojo = coordenadas x e y = verde)
            </p>
            <div class="container">
                <img src="uvmap.png" class="rounded">
                <p>Como podemos ver, las coordenadas 0,0 están en la esquina inferior izquierda y 1,1 está en la esquina superior derecha, tal como cualquiera esperaría. Ahora con estas coordenadas finalmente podemos crear sombreadores. Primero explicaré la ecuación matemática para cada sombreador y luego la conversión real a sombreadores. Lo que no explicaré es la conversión de matemáticas a código porque es fácil, no hay motivo y para los sombreadores grandes es divertido hacerlo.</p>
            </div>
        </section>
    </main> 
</body>
</html>